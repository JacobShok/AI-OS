/* -*- c -*- File generated by the BNF Converter (bnfc 2.9.6.1). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.h"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the shell_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.h"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE shell__scan_string(const char *str, yyscan_t scanner);
extern void shell__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void shell_lex_destroy(yyscan_t scanner);
extern char* shell_get_text(yyscan_t scanner);

extern yyscan_t shell__initialize_lexer(FILE * inp);

/* List reversal functions. */
ListCommand reverseListCommand(ListCommand l)
{
  ListCommand prev = 0;
  ListCommand tmp = 0;
  while (l)
  {
    tmp = l->listcommand_;
    l->listcommand_ = prev;
    prev = l;
    l = tmp;
  }
  return prev;
}
ListSimpleCommand reverseListSimpleCommand(ListSimpleCommand l)
{
  ListSimpleCommand prev = 0;
  ListSimpleCommand tmp = 0;
  while (l)
  {
    tmp = l->listsimplecommand_;
    l->listsimplecommand_ = prev;
    prev = l;
    l = tmp;
  }
  return prev;
}
ListWord reverseListWord(ListWord l)
{
  ListWord prev = 0;
  ListWord tmp = 0;
  while (l)
  {
    tmp = l->listword_;
    l->listword_ = prev;
    prev = l;
    l = tmp;
  }
  return prev;
}
ListRedirection reverseListRedirection(ListRedirection l)
{
  ListRedirection prev = 0;
  ListRedirection tmp = 0;
  while (l)
  {
    tmp = l->listredirection_;
    l->listredirection_ = prev;
    prev = l;
    l = tmp;
  }
  return prev;
}

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  Input input_;
  Command command_;
  Pipeline pipeline_;
  SimpleCommand simplecommand_;
  Redirection redirection_;
  ListCommand listcommand_;
  ListSimpleCommand listsimplecommand_;
  ListWord listword_;
  ListRedirection listredirection_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, shell_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _SEMI    /* ; */
%token          _LT      /* < */
%token          _GT      /* > */
%token          _DGT     /* >> */
%token          _KW_AI   /* AI */
%token          _BAR     /* | */
%token<_string> T_Word   /* Word */

%type <input_> Input
%type <command_> Command
%type <pipeline_> Pipeline
%type <simplecommand_> SimpleCommand
%type <redirection_> Redirection
%type <listcommand_> ListCommand
%type <listsimplecommand_> ListSimpleCommand
%type <listword_> ListWord
%type <listredirection_> ListRedirection

%start Input

%%

Input : ListCommand { $$ = make_StartInput($1); result->input_ = $$; }
;
Command : SimpleCommand { $$ = make_SimpleCmd($1); }
  | Pipeline { $$ = make_PipeCmd($1); }
  | _KW_AI ListWord { $$ = make_AICmd($2); }
;
Pipeline : ListSimpleCommand { $$ = make_PipeLine($1); }
;
SimpleCommand : T_Word ListWord ListRedirection { $$ = make_Cmd($1, $2, reverseListRedirection($3)); }
;
Redirection : _LT T_Word { $$ = make_RedirIn($2); }
  | _GT T_Word { $$ = make_RedirOut($2); }
  | _DGT T_Word { $$ = make_RedirAppend($2); }
;
ListCommand : /* empty */ { $$ = 0; }
  | Command { $$ = make_ListCommand($1, 0); }
  | Command _SEMI ListCommand { $$ = make_ListCommand($1, $3); }
;
ListSimpleCommand : /* empty */ { $$ = 0; }
  | SimpleCommand { $$ = make_ListSimpleCommand($1, 0); }
  | SimpleCommand _BAR ListSimpleCommand { $$ = make_ListSimpleCommand($1, $3); }
;
ListWord : /* empty */ { $$ = 0; }
  | T_Word ListWord { $$ = make_ListWord($1, $2); }
;
ListRedirection : /* empty */ { $$ = 0; }
  | ListRedirection Redirection { $$ = make_ListRedirection($2, $1); }
;

%%


/* Entrypoint: parse Input from file. */
Input pInput(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = shell__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  shell_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.input_;
  }
}

/* Entrypoint: parse Input from string. */
Input psInput(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = shell__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = shell__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  shell__delete_buffer(buf, scanner);
  shell_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.input_;
  }
}



