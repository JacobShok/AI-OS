/* File generated by the BNF Converter (bnfc 2.9.6.1). */

/*** Visitor Traversal Skeleton - MODIFIED FOR SHELL EXECUTION ***/
/* This traverses the abstract syntax tree and executes commands.
 * Uses visitor pattern - each node type has a visit function that:
 *   1. Processes the node (e.g., builds argv, sets up pipes)
 *   2. Automatically visits children
 *   3. Updates the execution context
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>

#include "Skeleton.h"
#include "../include/picobox.h"
#include "../include/exec_helpers.h"
#include "../include/pipe_helpers.h"
#include "../include/cmd_spec.h"

/*
 * Create a new execution context
 * Allocates and initializes all fields to empty/zero
 */
ExecContext *exec_context_new(void)
{
    ExecContext *ctx = calloc(1, sizeof(ExecContext));
    if (!ctx) {
        perror("calloc");
        return NULL;
    }

    /* Initialize argv array with small capacity - will grow as needed */
    ctx->argv_capacity = 16;
    ctx->argv = malloc(ctx->argv_capacity * sizeof(char *));
    if (!ctx->argv) {
        free(ctx);
        return NULL;
    }
    ctx->argc = 0;

    /* Initialize file descriptors to -1 (not open) */
    ctx->stdin_fd = -1;
    ctx->stdout_fd = -1;
    ctx->stderr_fd = -1;

    /* Initialize pipeline state */
    ctx->in_pipeline = 0;
    ctx->pipeline_position = 0;
    ctx->pipeline_total = 0;
    ctx->prev_pipe[0] = -1;
    ctx->prev_pipe[1] = -1;
    ctx->curr_pipe[0] = -1;
    ctx->curr_pipe[1] = -1;

    /* Initialize PID tracking array */
    ctx->pid_capacity = 8;
    ctx->pids = malloc(ctx->pid_capacity * sizeof(pid_t));
    if (!ctx->pids) {
        free(ctx->argv);
        free(ctx);
        return NULL;
    }
    ctx->pid_count = 0;

    /* Initialize execution state */
    ctx->exit_status = EXIT_OK;
    ctx->should_exit = 0;
    ctx->has_error = 0;

    return ctx;
}

/*
 * Free execution context and all allocated memory
 */
void exec_context_free(ExecContext *ctx)
{
    if (!ctx) return;

    /* Free current argv */
    if (ctx->argv) {
        for (int i = 0; i < ctx->argc; i++) {
            free(ctx->argv[i]);
        }
        free(ctx->argv);
    }

    /* Close any open file descriptors */
    if (ctx->stdin_fd != -1) {
        close(ctx->stdin_fd);
    }
    if (ctx->stdout_fd != -1) {
        close(ctx->stdout_fd);
    }
    if (ctx->stderr_fd != -1) {
        close(ctx->stderr_fd);
    }

    /* Free PID array */
    free(ctx->pids);

    free(ctx);
}

/*
 * Reset command-specific state (argv and file descriptors)
 * Used between commands in a sequence or pipeline
 */
void exec_context_reset_command(ExecContext *ctx)
{
    /* Free and reset argv */
    for (int i = 0; i < ctx->argc; i++) {
        free(ctx->argv[i]);
        ctx->argv[i] = NULL;
    }
    ctx->argc = 0;

    /* Close and reset file descriptors */
    if (ctx->stdin_fd != -1) {
        close(ctx->stdin_fd);
        ctx->stdin_fd = -1;
    }
    if (ctx->stdout_fd != -1) {
        close(ctx->stdout_fd);
        ctx->stdout_fd = -1;
    }
    if (ctx->stderr_fd != -1) {
        close(ctx->stderr_fd);
        ctx->stderr_fd = -1;
    }
}

/*
 * Visit Input node - entry point for AST traversal
 * Visits all commands in the input sequence
 */

 /* p - Pointer to Input struct
 ->u - Access the union member, can have multiple in our case simple pipe AI
 startInput_ - Access the startInput variant of the union
 listcommand_ - Access the listcommand field inside startInput*/

 // note list command is a linked list of commands
void visitInput(Input p, ExecContext *ctx)
{
    switch(p->kind) // entry into the ast
    {
    case is_StartInput:
        /* Visit all commands in sequence (separated by ;) */
        visitListCommand(p->u.startInput_.listcommand_, ctx);
        break;

    default:
        fprintf(stderr, "Error: bad kind field when visiting Input!\n");
        exit(1);
    }
}

/*
 * Visit AI Command - handles "AI <question>" syntax
 *
 * Example: AI how do I list all files
 *
 * This converts the ListWord into a query string and calls the AI command.
 * AI commands run in the PARENT process (no fork) because they're interactive.
 */
void visitAICommand(ListWord listword, ExecContext *ctx)
{
    char query[2048] = "";
    size_t len = 0;

    /* Build query string from word list */
    ListWord curr = listword;
    while (curr && curr->word_) {
        if (len > 0 && len < sizeof(query) - 1) {
            query[len++] = ' ';  /* Add space between words */
        }

        size_t word_len = strlen(curr->word_);
        if (len + word_len < sizeof(query) - 1) {
            strcpy(query + len, curr->word_);
            len += word_len;
        }

        curr = curr->listword_;
    }
    query[len] = '\0';

    /* Find the AI command in registry */
    const cmd_spec_t *spec = find_command("AI");
    if (!spec) {
        fprintf(stderr, "Error: AI command not registered\n");
        fprintf(stderr, "Make sure register_ai_command() was called at startup.\n");
        ctx->exit_status = EXIT_ERROR;
        return;
    }

    /* Build argv for AI command */
    char *argv[] = {"AI", query, NULL};

    /* Run the AI command in parent process (no fork needed) */
    int status = spec->run(2, argv);
    ctx->exit_status = status;
}

/*
 * Visit Command node - dispatches to SimpleCmd, PipeCmd, or AICmd
 */
void visitCommand(Command p, ExecContext *ctx)
{
    switch(p->kind)
    {
    case is_SimpleCmd:
        /* Simple command - just one command with args and redirections */
        visitSimpleCommand(p->u.simpleCmd_.simplecommand_, ctx);
        break;
    case is_PipeCmd:
        /* Pipeline command - multiple commands connected with | */
        visitPipeline(p->u.pipeCmd_.pipeline_, ctx);
        break;
    case is_AICmd:
        /* AI command - interactive assistant */
        visitAICommand(p->u.aICmd_.listword_, ctx);
        break;

    default:
        fprintf(stderr, "Error: bad kind field when visiting Command!\n");
        exit(1);
    }
}

/*
 * Visit Pipeline - REFACTORED per plan.md Phase 4
 *
 * THIS IS THE KEY REFACTORING!
 * PROFESSOR'S WORDS: "You take this function and cut it into pieces,
 * and put them into all the different visit nodes."
 *
 * OLD APPROACH (WRONG):
 *   1. Collect all commands
 *   2. Call exec_pipeline() monolithic function
 *
 * NEW APPROACH (CORRECT):
 *   1. Create pipes HERE in visitPipeline
 *   2. Fork HERE in visitPipeline
 *   3. visitSimpleCommand handles the exec (when in_pipeline flag is set)
 *   4. Logic is SCATTERED across the AST nodes
 */
void visitPipeline(Pipeline p, ExecContext *ctx)
{
    switch(p->kind)
    {
    case is_PipeLine:
    {
        /* Count commands in pipeline */
        int cmd_count = 0;
        ListSimpleCommand temp = p->u.pipeLine_.listsimplecommand_;
        while (temp) {
            cmd_count++;
            temp = temp->listsimplecommand_;
        }

        /* Set pipeline context */
        ctx->in_pipeline = 1; // one cmd in pipeline
        ctx->pipeline_total = cmd_count; // total commands
        ctx->prev_pipe[0] = -1; // set pipe ctx
        ctx->prev_pipe[1] = -1;

        /* Ensure PIDs array is large enough */
        if (ctx->pid_count + cmd_count > ctx->pid_capacity) {
            ctx->pid_capacity = ctx->pid_count + cmd_count;
            ctx->pids = realloc(ctx->pids, ctx->pid_capacity * sizeof(pid_t));
            if (!ctx->pids) {
                perror("realloc");
                ctx->has_error = 1;
                break;
            }
        }

        /* Execute each command in pipeline */
        ListSimpleCommand sc_list = p->u.pipeLine_.listsimplecommand_;
        int position = 0;

        while (sc_list) {
            ctx->pipeline_position = position;

            /* Create pipe for all except last command */
            if (position < cmd_count - 1) {
                if (pipe(ctx->curr_pipe) < 0) {
                    perror("pipe");
                    ctx->has_error = 1;
                    break;
                }
            } else {
                ctx->curr_pipe[0] = -1;
                ctx->curr_pipe[1] = -1;
            }

            /* Fork for this command */
            pid_t pid = fork();

            if (pid < 0) {
                perror("fork");
                ctx->has_error = 1;
                break;
            }

            if (pid == 0) {
                /* === CHILD PROCESS === */

                /* Connect stdin to previous pipe (if not first) */
                if (ctx->prev_pipe[0] != -1) {
                    dup2(ctx->prev_pipe[0], STDIN_FILENO);
                    close(ctx->prev_pipe[0]);
                    close(ctx->prev_pipe[1]);
                }

                /* Connect stdout to current pipe (if not last) */
                if (ctx->curr_pipe[1] != -1) {
                    dup2(ctx->curr_pipe[1], STDOUT_FILENO);
                    close(ctx->curr_pipe[0]);
                    close(ctx->curr_pipe[1]);
                }

                /* Execute this SimpleCommand
                 * visitSimpleCommand will see in_pipeline==1
                 * and will NOT fork again, just exec
                 */
                visitSimpleCommand(sc_list->simplecommand_, ctx);

                /* If visitSimpleCommand didn't exec, exit */
                _exit(ctx->exit_status);
            }

            /* === PARENT PROCESS === */

            /* Save PID */
            ctx->pids[ctx->pid_count++] = pid;

            /* Close previous pipe in parent */
            if (ctx->prev_pipe[0] != -1) {
                close(ctx->prev_pipe[0]);
                close(ctx->prev_pipe[1]);
            }

            /* Current pipe becomes previous for next iteration */
            ctx->prev_pipe[0] = ctx->curr_pipe[0];
            ctx->prev_pipe[1] = ctx->curr_pipe[1];

            /* Move to next command */
            sc_list = sc_list->listsimplecommand_;
            position++;
        }

        /* Close last pipe in parent */
        if (ctx->prev_pipe[0] != -1) {
            close(ctx->prev_pipe[0]);
            close(ctx->prev_pipe[1]);
        }

        /* Wait for all children */
        for (int i = 0; i < ctx->pid_count; i++) {
            int status;
            if (waitpid(ctx->pids[i], &status, 0) >= 0) {
                /* Last command's status is pipeline's status */
                if (i == ctx->pid_count - 1) {
                    if (WIFEXITED(status))
                        ctx->exit_status = WEXITSTATUS(status);
                    else if (WIFSIGNALED(status))
                        ctx->exit_status = 128 + WTERMSIG(status);
                }
            }
        }

        /* Reset pipeline state */
        ctx->pid_count = 0;
        ctx->in_pipeline = 0;

        break;
    }

    default:
        fprintf(stderr, "Error: bad kind field when visiting Pipeline!\n");
        exit(1);
    }
}

/*
 * Helper function: Execute command in child process
 * REFACTORED per plan.md Phase 3
 *
 * This runs AFTER fork(), in the child process only.
 * It handles both registry commands and external commands.
 *
 * For registry commands: exec picobox itself (industry standard)
 * For external commands: exec the command directly
 */
static void execute_in_child(ExecContext *ctx)
{
    /* Check if it's a registry command */
    const cmd_spec_t *spec = find_command(ctx->argv[0]);

    if (spec != NULL) {
        /* Registry command - run directly in the child
         *
         * NOTE: We're in a forked child process, so it's safe to run directly.
         * This avoids the complexity of re-exec'ing picobox.
         *
         * The professor mentioned exec'ing picobox itself, but for registry
         * commands in a forked child, we can just call the function directly
         * and then _exit() to terminate the child.
         */
        int status = spec->run(ctx->argc, ctx->argv);
        fflush(stdout);
        fflush(stderr);
        _exit(status);
    } else {
        /* External command (ls, cat, grep, etc.) */
        execvp(ctx->argv[0], ctx->argv);
        perror(ctx->argv[0]);
        _exit(127);
    }
}

/*
 * Helper function: cd built-in
 */
static int builtin_cd(ExecContext *ctx)
{
    const char *dir;
    if (ctx->argc < 2) {
        dir = getenv("HOME");
        if (!dir) {
            fprintf(stderr, "cd: HOME not set\n");
            return EXIT_ERROR;
        }
    } else {
        dir = ctx->argv[1];
    }

    if (chdir(dir) != 0) {
        perror("cd");
        return EXIT_ERROR;
    }
    return EXIT_OK;
}

/*
 * Helper function: help built-in
 */
static int builtin_help(ExecContext *ctx)
{
    (void)ctx;  /* Unused */

    printf("PicoBox BNFC Shell (Visitor Pattern - Refactored)\n");
    printf("Built-in commands:\n");
    printf("  exit       - Exit the shell\n");
    printf("  help       - Show this help message\n");
    printf("  cd [DIR]   - Change directory\n");

    return EXIT_OK;
}

/*
 * Visit SimpleCommand - REFACTORED per plan.md Phase 3
 *
 * KEY INSIGHT: This function has TWO MODES:
 * 1. STANDALONE mode (in_pipeline == 0): We fork here
 * 2. PIPELINE mode (in_pipeline == 1): Already forked by visitPipeline, just exec
 *
 * This is the correct visitor pattern approach.
 */
void visitSimpleCommand(SimpleCommand p, ExecContext *ctx)
{
    switch(p->kind)
    {
    case is_Cmd:
        /* Reset command state for new command */
        exec_context_reset_command(ctx);

        /* Build argv by visiting word nodes */
        visitWord(p->u.cmd_.word_, ctx); // uses command data structure to build ctx
        visitListWord(p->u.cmd_.listword_, ctx);

        /* Visit redirections (opens files, stores fds in context) */
        visitListRedirection(p->u.cmd_.listredirection_, ctx); // stores fds in ctx for redir applying later

        /* Check for errors during tree walk */
        if (ctx->has_error) {
            break;
        }

        /* NULL-terminate argv */
        if (ctx->argc < ctx->argv_capacity) {
            ctx->argv[ctx->argc] = NULL;
        }

        /* Skip if no command */
        if (ctx->argc == 0 || !ctx->argv[0]) {
            break;
        }

        /* === EXECUTION LOGIC === */

        if (ctx->in_pipeline) {
            /* MODE 1: We're in a pipeline - already forked in visitPipeline()
             * Just apply redirections and exec */

            /* Apply file redirections */
            if (ctx->stdin_fd != -1) {
                dup2(ctx->stdin_fd, STDIN_FILENO);
                close(ctx->stdin_fd);
            }

            if (ctx->stdout_fd != -1) {
                dup2(ctx->stdout_fd, STDOUT_FILENO);
                close(ctx->stdout_fd);
            }

            /* Execute command (will not return) */
            execute_in_child(ctx);

            /* Should never reach here */
            _exit(127);

        } else {
            /* MODE 2: Standalone command - need to fork here */

            /* Check for built-ins that MUST run in parent */
            if (strcmp(ctx->argv[0], "exit") == 0) {
                ctx->should_exit = 1;
                ctx->exit_status = EXIT_OK;
                break;
            } else if (strcmp(ctx->argv[0], "cd") == 0) {
                ctx->exit_status = builtin_cd(ctx);
                break;
            } else if (strcmp(ctx->argv[0], "help") == 0) {
                ctx->exit_status = builtin_help(ctx);
                break;
            }

            /* Fork for all other commands (registry + external) */
            pid_t pid = fork();

            if (pid < 0) {
                perror("fork");
                ctx->exit_status = EXIT_ERROR;
                break;
            }

            if (pid == 0) {
                /* === CHILD PROCESS === */

                /* Apply file redirections */
                if (ctx->stdin_fd != -1) {
                    dup2(ctx->stdin_fd, STDIN_FILENO);
                    close(ctx->stdin_fd);
                }

                if (ctx->stdout_fd != -1) {
                    dup2(ctx->stdout_fd, STDOUT_FILENO);
                    close(ctx->stdout_fd);
                }

                /* Execute command (will not return) */
                execute_in_child(ctx);

                /* Should never reach here */
                _exit(127);
            }

            /* === PARENT PROCESS === */

            /* Close file descriptors in parent */
            if (ctx->stdin_fd != -1) {
                close(ctx->stdin_fd);
                ctx->stdin_fd = -1;
            }
            if (ctx->stdout_fd != -1) {
                close(ctx->stdout_fd);
                ctx->stdout_fd = -1;
            }

            /* Wait for child */
            int status;
            if (waitpid(pid, &status, 0) >= 0) {
                if (WIFEXITED(status))
                    ctx->exit_status = WEXITSTATUS(status);
                else if (WIFSIGNALED(status))
                    ctx->exit_status = 128 + WTERMSIG(status);
            } else {
                perror("waitpid");
                ctx->exit_status = EXIT_ERROR;
            }
        }

        break;

    default:
        fprintf(stderr, "Error: bad kind field when visiting SimpleCommand!\n");
        exit(1);
    }
}

/*
 * Visit Redirection - OPENS FILES and stores file descriptors
 * REFACTORED per plan.md Phase 2
 *
 * This is the CORRECT approach for visitor pattern:
 * - Open file immediately at the node level
 * - Store FD in context (not filename!)
 * - dup2() happens later in child process
 */
void visitRedirection(Redirection p, ExecContext *ctx)
{
    int fd;

    switch(p->kind)
    {
    case is_RedirIn:
        /* Input redirection: < file */
        fd = open(p->u.redirIn_.word_, O_RDONLY);
        if (fd < 0) {
            perror(p->u.redirIn_.word_);
            ctx->has_error = 1;
            return;
        }
        /* Close previous stdin_fd if set (multiple redirections) */
        if (ctx->stdin_fd != -1) {
            close(ctx->stdin_fd);
        }
        ctx->stdin_fd = fd;
        break;

    case is_RedirOut:
        /* Output redirection: > file (truncate) */
        fd = open(p->u.redirOut_.word_, O_WRONLY | O_CREAT | O_TRUNC, 0644);
        if (fd < 0) {
            perror(p->u.redirOut_.word_);
            ctx->has_error = 1;
            return;
        }
        if (ctx->stdout_fd != -1) {
            close(ctx->stdout_fd);
        }
        ctx->stdout_fd = fd;
        break;

    case is_RedirAppend:
        /* Append redirection: >> file */
        fd = open(p->u.redirAppend_.word_, O_WRONLY | O_CREAT | O_APPEND, 0644);
        if (fd < 0) {
            perror(p->u.redirAppend_.word_);
            ctx->has_error = 1;
            return;
        }
        if (ctx->stdout_fd != -1) {
            close(ctx->stdout_fd);
        }
        ctx->stdout_fd = fd;
        break;

    default:
        fprintf(stderr, "Error: bad kind field when visiting Redirection!\n");
        exit(1);
    }
}

/*
 * Visit list of commands (separated by ;)
 * Executes each command in sequence
 */
void visitListCommand(ListCommand listcommand, ExecContext *ctx)
{
    while(listcommand != 0) // loop through linked list
    {
        visitCommand(listcommand->command_, ctx);

        /* Check if shell should exit */
        if (ctx->should_exit) {
            break;
        }

        listcommand = listcommand->listcommand_;
    }
}

/*
 * Visit list of simple commands (in a pipeline)
 * REFACTORED per plan.md Phase 4
 *
 * This function is NO LONGER NEEDED!
 * visitPipeline() now handles iteration over the list directly.
 *
 * We keep this as a stub for now (in case BNFC-generated code calls it),
 * but it should never actually be called.
 */
void visitListSimpleCommand(ListSimpleCommand listsimplecommand, ExecContext *ctx)
{
    (void)listsimplecommand;
    (void)ctx;
    fprintf(stderr, "ERROR: visitListSimpleCommand() should not be called!\n");
    fprintf(stderr, "       visitPipeline() handles the list directly now.\n");
    exit(1);
}

/*
 * Visit list of words (arguments to a command)
 * Adds each word to argv
 */
void visitListWord(ListWord listword, ExecContext *ctx)
{
    while(listword != 0)
    {
        visitWord(listword->word_, ctx);
        listword = listword->listword_;
    }
}

/*
 * Visit list of redirections
 * Adds each redirection to context
 */
void visitListRedirection(ListRedirection listredirection, ExecContext *ctx)
{
    while(listredirection != 0)
    {
        visitRedirection(listredirection->redirection_, ctx);
        listredirection = listredirection->listredirection_;
    }
}

/*
 * Visit Word - adds word to argv
 * This is called for command name and each argument
 */
void visitWord(Word p, ExecContext *ctx)
{
    /* Grow argv if needed */
    if (ctx->argc >= ctx->argv_capacity - 1) {  /* -1 for NULL terminator */
        ctx->argv_capacity *= 2;
        ctx->argv = realloc(ctx->argv, ctx->argv_capacity * sizeof(char *));
        if (!ctx->argv) {
            perror("realloc");
            exit(1);
        }
    }

    /* Add word to argv */
    ctx->argv[ctx->argc] = strdup(p);
    if (!ctx->argv[ctx->argc]) {
        perror("strdup");
        exit(1);
    }
    ctx->argc++;
}

/* These visitor functions are not used in shell context */
void visitIdent(Ident i, ExecContext *ctx) { (void)i; (void)ctx; }
void visitInteger(Integer i, ExecContext *ctx) { (void)i; (void)ctx; }
void visitDouble(Double d, ExecContext *ctx) { (void)d; (void)ctx; }
void visitChar(Char c, ExecContext *ctx) { (void)c; (void)ctx; }
void visitString(String s, ExecContext *ctx) { (void)s; (void)ctx; }

