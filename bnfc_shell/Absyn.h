/* File generated by the BNF Converter (bnfc 2.9.6.1). */

#ifndef ABSYN_HEADER
#define ABSYN_HEADER

/* strdup was not in the ISO C standard before 6/2019 (C2x), but in POSIX 1003.1.
 * See: https://en.cppreference.com/w/c/experimental/dynamic/strdup
 * Setting _POSIX_C_SOURCE to 200809L activates strdup in string.h.
 */
#define _POSIX_C_SOURCE 200809L

#include <stddef.h>  /* NULL */
#include <string.h>  /* strdup */

/* C++ Abstract Syntax Interface.*/

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef char* String;
typedef char* Ident;
typedef char* Word;

/********************   Forward Declarations    ***********************/
struct Input_;
typedef struct Input_ *Input;

struct Command_;
typedef struct Command_ *Command;

struct ListCommand_;
typedef struct ListCommand_ *ListCommand;

struct ListWord_;
typedef struct ListWord_ *ListWord;

/********************   Abstract Syntax Classes    ********************/

struct Input_
{
  enum { is_StartInput } kind;
  union
  {
    struct { ListCommand listcommand_; } startInput_;
  } u;
};

Input make_StartInput(ListCommand p0);

struct Command_
{
  enum { is_SimpleCmd } kind;
  union
  {
    struct { ListWord listword_; Word word_; } simpleCmd_;
  } u;
};

Command make_SimpleCmd(Word p0, ListWord p1);

struct ListCommand_
{
  Command command_;
  ListCommand listcommand_;
};

ListCommand make_ListCommand(Command p1, ListCommand p2);

struct ListWord_
{
  Word word_;
  ListWord listword_;
};

ListWord make_ListWord(Word p1, ListWord p2);

/***************************   Cloning   ******************************/

Input clone_Input(Input p);
Command clone_Command(Command p);
ListCommand clone_ListCommand(ListCommand p);
ListWord clone_ListWord(ListWord p);

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_Input(Input p);
void free_Command(Command p);
void free_ListCommand(ListCommand p);
void free_ListWord(ListWord p);


#endif
