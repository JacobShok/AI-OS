/* File generated by the BNF Converter (bnfc 2.9.6.1). */

/* C Abstract Syntax Implementation. */

#include <stdio.h>
#include <stdlib.h>
#include "Absyn.h"

/********************   StartInput    ********************/

Input make_StartInput(ListCommand p1)
{
    Input tmp = (Input) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating StartInput!\n");
        exit(1);
    }
    tmp->kind = is_StartInput;
    tmp->u.startInput_.listcommand_ = p1;
    return tmp;
}

/********************   SimpleCmd    ********************/

Command make_SimpleCmd(Word p1, ListWord p2)
{
    Command tmp = (Command) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SimpleCmd!\n");
        exit(1);
    }
    tmp->kind = is_SimpleCmd;
    tmp->u.simpleCmd_.word_ = p1;
    tmp->u.simpleCmd_.listword_ = p2;
    return tmp;
}

/********************   ListCommand    ********************/

ListCommand make_ListCommand(Command p1, ListCommand p2)
{
    ListCommand tmp = (ListCommand) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListCommand!\n");
        exit(1);
    }
    tmp->command_ = p1;
    tmp->listcommand_ = p2;
    return tmp;
}

/********************   ListWord    ********************/

ListWord make_ListWord(Word p1, ListWord p2)
{
    ListWord tmp = (ListWord) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListWord!\n");
        exit(1);
    }
    tmp->word_ = p1;
    tmp->listword_ = p2;
    return tmp;
}

/***************************   Cloning   ******************************/

Input clone_Input(Input p)
{
  switch(p->kind)
  {
  case is_StartInput:
    return make_StartInput (clone_ListCommand(p->u.startInput_.listcommand_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Input!\n");
    exit(1);
  }
}

Command clone_Command(Command p)
{
  switch(p->kind)
  {
  case is_SimpleCmd:
    return make_SimpleCmd
      ( strdup(p->u.simpleCmd_.word_)
      , clone_ListWord(p->u.simpleCmd_.listword_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Command!\n");
    exit(1);
  }
}

ListCommand clone_ListCommand(ListCommand listcommand)
{
  if (listcommand)
  {
    /* clone of non-empty list */
    return make_ListCommand
      ( clone_Command(listcommand->command_)
      , clone_ListCommand(listcommand->listcommand_)
      );
  }
  else return NULL; /* clone of empty list */
}

ListWord clone_ListWord(ListWord listword)
{
  if (listword)
  {
    /* clone of non-empty list */
    return make_ListWord
      ( strdup(listword->word_)
      , clone_ListWord(listword->listword_)
      );
  }
  else return NULL; /* clone of empty list */
}

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_Input(Input p)
{
  switch(p->kind)
  {
  case is_StartInput:
    free_ListCommand(p->u.startInput_.listcommand_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Input!\n");
    exit(1);
  }
  free(p);
}

void free_Command(Command p)
{
  switch(p->kind)
  {
  case is_SimpleCmd:
    free(p->u.simpleCmd_.word_);
    free_ListWord(p->u.simpleCmd_.listword_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Command!\n");
    exit(1);
  }
  free(p);
}

void free_ListCommand(ListCommand listcommand)
{
  if (listcommand)
  {
    free_Command(listcommand->command_);
    free_ListCommand(listcommand->listcommand_);
    free(listcommand);
  }
}

void free_ListWord(ListWord listword)
{
  if (listword)
  {
    free(listword->word_);
    free_ListWord(listword->listword_);
    free(listword);
  }
}

